<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åœ°ç‹±ç‰ˆè¿·å®« - æ¤°æ¤°ç”µç«</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Orbitron", "Microsoft YaHei", Arial, sans-serif;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f35 50%, #0f1420 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #fff;
            position: relative;
            overflow-x: hidden;
        }

        .bg-image {
            width: 100%;
            max-width: 1400px;
            height: auto;
            display: block;
            margin: 0 auto 20px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        .container {
            max-width: 1200px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 42px;
            font-weight: 900;
            background: linear-gradient(90deg, #00ffff, #00d4ff, #ffa500, #00ffff);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            animation: titleGlow 3s ease-in-out infinite;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.8));
        }

        @keyframes titleGlow {
            0%, 100% {
                filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.8)) brightness(1);
            }
            50% {
                filter: drop-shadow(0 0 20px rgba(0, 255, 255, 1)) brightness(1.2);
            }
        }

        .subtitle {
            font-size: 20px;
            color: #00ffff;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .game-area {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }

        .maze-container {
            background: linear-gradient(145deg, rgba(10, 15, 30, 0.8), rgba(5, 10, 20, 0.9));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 
                0 0 30px rgba(0, 255, 255, 0.2),
                inset 0 0 50px rgba(0, 0, 0, 0.5);
        }

        .maze-canvas {
            display: block;
            background: #111;
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }

        .preview-container {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid rgba(0, 255, 255, 0.3);
        }

        .preview-title {
            font-size: 16px;
            color: #ffa500;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }

        .preview-canvas {
            display: block;
            background: #0a0a0a;
            border: 1px solid rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            opacity: 0.8;
        }

        .control-panel {
            background: linear-gradient(145deg, rgba(0, 60, 80, 0.3), rgba(0, 40, 60, 0.4));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 
                0 0 25px rgba(0, 255, 255, 0.2),
                inset 0 0 30px rgba(0, 0, 0, 0.3);
            min-width: 280px;
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-title {
            font-size: 18px;
            color: #ffa500;
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: 2px solid rgba(255, 165, 0, 0.5);
            padding-bottom: 5px;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }

        .info-label {
            color: #00ffff;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
        }

        .info-value {
            color: #ffa500;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .direction-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 10px 0;
        }

        .control-btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 200, 255, 0.3));
            border: 2px solid #00ffff;
            color: #00ffff;
            font-size: 24px;
            font-weight: bold;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .control-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 5px 30px rgba(0, 255, 255, 0.6);
            border-color: #ffa500;
            color: #ffa500;
        }

        .control-btn:active:not(:disabled) {
            transform: translateY(-1px);
        }

        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .action-btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 200, 255, 0.3));
            border: 2px solid #00ffff;
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 30px rgba(0, 255, 255, 0.6);
            border-color: #ffa500;
            color: #ffa500;
        }

        .action-btn.success {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 200, 100, 0.3));
            border-color: #00ff88;
            color: #00ff88;
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .back-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            border-color: #ffa500;
            color: #ffa500;
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(20, 25, 45, 0.98), rgba(15, 20, 35, 1));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 
                0 0 60px rgba(0, 255, 255, 0.3),
                0 0 100px rgba(255, 165, 0, 0.2);
            z-index: 2000;
            text-align: center;
            display: none;
        }

        .message.show {
            display: block;
            animation: messageAppear 0.3s ease-out;
        }

        @keyframes messageAppear {
            from {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .message-title {
            font-size: 32px;
            color: #00ffff;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .message-text {
            font-size: 18px;
            color: #a0d0e0;
            margin-bottom: 20px;
        }

        @media (max-width: 1024px) {
            .bg-image {
                max-width: 100%;
            }
        }

        @media (max-width: 768px) {
            .bg-image {
                margin-bottom: 15px;
                border-radius: 5px;
            }

            .title {
                font-size: 32px;
            }

            .game-area {
                flex-direction: column;
            }

            .maze-canvas {
                max-width: 100%;
            }

            .control-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <img src="beijingtu.jpg" alt="æ¤°æ¤°ç”µç«" class="bg-image">
    <button class="back-btn" onclick="location.href='index.html'">â† è¿”å›é¦–é¡µ</button>

    <div class="container">
        <div class="header">
            <div class="title">ğŸ—ºï¸ è¿·å®«æ¢ç´¢ ğŸ—ºï¸</div>
            <div class="subtitle">10Ã—10 è¿·å®«é—¯å…³</div>
        </div>

        <div class="game-area">
            <div class="maze-container">
                <canvas id="mazeCanvas" class="maze-canvas" width="300" height="300"></canvas>
                <div class="preview-container" id="previewContainer" style="display: none;">
                    <div class="preview-title">ğŸ—ºï¸ å®Œæ•´è¿·å®«åœ°å›¾</div>
                    <canvas id="previewCanvas" class="preview-canvas" width="300" height="300"></canvas>
                </div>
            </div>

            <div class="control-panel">
                <div class="info-section">
                    <div class="info-title">ğŸ“Š æ¸¸æˆä¿¡æ¯</div>
                    <div class="info-item">
                        <span class="info-label">ğŸ‘£ å·²èµ°æ­¥æ•°:</span>
                        <span class="info-value" id="steps">0</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ğŸ¯ æœ€çŸ­è·¯å¾„:</span>
                        <span class="info-value" id="shortestPath">?</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ğŸ“ å½“å‰ä½ç½®:</span>
                        <span class="info-value" id="position">èµ·ç‚¹</span>
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">ğŸ® æ–¹å‘æ§åˆ¶</div>
                    <div class="direction-pad">
                        <div></div>
                        <button class="control-btn" id="btnUp" onclick="move('up')">â†‘</button>
                        <div></div>
                        <button class="control-btn" id="btnLeft" onclick="move('left')">â†</button>
                        <button class="control-btn" id="btnDown" onclick="move('down')">â†“</button>
                        <button class="control-btn" id="btnRight" onclick="move('right')">â†’</button>
                    </div>
                </div>

                <div class="controls">
                    <button class="action-btn" onclick="newGame()">ğŸ² æ–°æ¸¸æˆ</button>
                    <button class="action-btn success" onclick="exportGame()">ğŸ’¾ å¯¼å‡ºå­˜æ¡£</button>
                    <button class="action-btn success" onclick="importGame()">ğŸ“‚ å¯¼å…¥å­˜æ¡£</button>
                </div>
            </div>
        </div>
    </div>

    <div class="message" id="message">
        <div class="message-title" id="messageTitle"></div>
        <div class="message-text" id="messageText"></div>
        <button class="action-btn" onclick="hideMessage()">ç¡®å®š</button>
    </div>

    <script>
        const MAZE_SIZE = 10;
        const CELL_SIZE = 30;
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');

        let maze = [];
        let playerPos = { x: 0, y: 0 };
        let exitPos = { x: MAZE_SIZE - 1, y: MAZE_SIZE - 1 };
        let explored = [];
        let visitedCells = new Set(); // è®°å½•å·²èµ°è¿‡çš„æ ¼å­ï¼ˆç”¨äºæ­¥æ•°ç»Ÿè®¡ï¼‰
        let moveHistory = [];
        let steps = 0;
        let shortestPathLength = 0;
        let correctPath = []; // å­˜å‚¨æ­£ç¡®è·¯å¾„
        let gameEnded = false;

        // BFSè®¡ç®—æœ€çŸ­è·¯å¾„
        function findShortestPath() {
            const queue = [{x: 0, y: 0, dist: 0}];
            const visited = Array(MAZE_SIZE).fill(null).map(() => Array(MAZE_SIZE).fill(false));
            visited[0][0] = true;
            
            const directions = [
                { dx: 0, dy: -1 },
                { dx: 1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }
            ];
            
            while (queue.length > 0) {
                const curr = queue.shift();
                
                if (curr.x === MAZE_SIZE - 1 && curr.y === MAZE_SIZE - 1) {
                    return curr.dist;
                }
                
                for (let dir of directions) {
                    const newX = curr.x + dir.dx;
                    const newY = curr.y + dir.dy;
                    
                    if (newX >= 0 && newX < MAZE_SIZE && newY >= 0 && newY < MAZE_SIZE &&
                        !visited[newY][newX] && maze[newY][newX] === 0) {
                        visited[newY][newX] = true;
                        queue.push({x: newX, y: newY, dist: curr.dist + 1});
                    }
                }
            }
            return -1;
        }

        // è¿·å®«ç”Ÿæˆ - åˆ›å»ºå”¯ä¸€æ­£ç¡®è·¯å¾„ + 3-5ä¸ªæ­»èƒ¡åŒï¼ˆè·¯å¾„ä¹‹é—´æœ‰å¢™éš”å¼€ï¼‰
        function generateMaze() {
            let attempts = 0;
            let pathLength = 0;
            
            // é‡å¤ç”Ÿæˆç›´åˆ°æ»¡è¶³è·¯å¾„é•¿åº¦è¦æ±‚
            while (attempts < 100) {
                // åˆå§‹åŒ–è¿·å®«ï¼Œå…¨éƒ¨ä¸ºå¢™
                maze = Array(MAZE_SIZE).fill(null).map(() => Array(MAZE_SIZE).fill(1));
                explored = Array(MAZE_SIZE).fill(null).map(() => Array(MAZE_SIZE).fill(false));
                correctPath = [];
                
                // ç”Ÿæˆå”¯ä¸€æ­£ç¡®è·¯å¾„ï¼ˆç¡®ä¿è·¯å¾„ä¹‹é—´æœ‰å¢™éš”å¼€ï¼‰
                let x = 0, y = 0;
                correctPath.push({x, y});
                maze[y][x] = 0;
                
                // ä½¿ç”¨æ”¹è¿›çš„è·¯å¾„ç”Ÿæˆï¼Œç¡®ä¿è·¯å¾„ä¸ä¼šç›¸é‚»
                const targetSteps = 18 + Math.floor(Math.random() * 8); // 18-25æ­¥ï¼ˆç›®æ ‡22æ­¥å·¦å³ï¼‰
                let stepCount = 0;
                
                while (stepCount < targetSteps && (x < MAZE_SIZE - 1 || y < MAZE_SIZE - 1)) {
                    const possibleMoves = [];
                    
                    // å‘å³ç§»åŠ¨ï¼ˆç¡®ä¿ä¸ä¼šä¸å…¶ä»–è·¯å¾„ç›¸é‚»ï¼‰
                    if (x < MAZE_SIZE - 1) {
                        const nx = x + 1;
                        const ny = y;
                        // æ£€æŸ¥æ˜¯å¦ä¼šä¸å·²æœ‰è·¯å¾„ç›¸é‚»ï¼ˆé™¤äº†æ¥çš„æ–¹å‘ï¼‰
                        let isValid = true;
                        // æ£€æŸ¥ä¸Šæ–¹
                        if (ny > 0 && maze[ny - 1][nx] === 0 && !(nx === x && ny - 1 === y)) isValid = false;
                        // æ£€æŸ¥ä¸‹æ–¹
                        if (ny < MAZE_SIZE - 1 && maze[ny + 1][nx] === 0 && !(nx === x && ny + 1 === y)) isValid = false;
                        
                        if (isValid || correctPath.length === 1) {
                            possibleMoves.push({dx: 1, dy: 0});
                        }
                    }
                    
                    // å‘ä¸‹ç§»åŠ¨ï¼ˆç¡®ä¿ä¸ä¼šä¸å…¶ä»–è·¯å¾„ç›¸é‚»ï¼‰
                    if (y < MAZE_SIZE - 1) {
                        const nx = x;
                        const ny = y + 1;
                        // æ£€æŸ¥æ˜¯å¦ä¼šä¸å·²æœ‰è·¯å¾„ç›¸é‚»ï¼ˆé™¤äº†æ¥çš„æ–¹å‘ï¼‰
                        let isValid = true;
                        // æ£€æŸ¥å·¦ä¾§
                        if (nx > 0 && maze[ny][nx - 1] === 0 && !(nx - 1 === x && ny === y)) isValid = false;
                        // æ£€æŸ¥å³ä¾§
                        if (nx < MAZE_SIZE - 1 && maze[ny][nx + 1] === 0 && !(nx + 1 === x && ny === y)) isValid = false;
                        
                        if (isValid || correctPath.length === 1) {
                            possibleMoves.push({dx: 0, dy: 1});
                        }
                    }
                    
                    if (possibleMoves.length > 0) {
                        const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        x += move.dx;
                        y += move.dy;
                        correctPath.push({x, y});
                        maze[y][x] = 0;
                        stepCount++;
                    } else {
                        // å¦‚æœæ²¡æœ‰æœ‰æ•ˆç§»åŠ¨ï¼Œç›´æ¥å‘ç»ˆç‚¹ç§»åŠ¨
                        break;
                    }
                }
                
                // ç¡®ä¿åˆ°è¾¾ç»ˆç‚¹ï¼ˆå¦‚æœè¿˜æ²¡åˆ°ï¼‰
                while (x < MAZE_SIZE - 1) {
                    x++;
                    correctPath.push({x, y});
                    maze[y][x] = 0;
                }
                while (y < MAZE_SIZE - 1) {
                    y++;
                    correctPath.push({x, y});
                    maze[y][x] = 0;
                }
                
                // æ·»åŠ 8-12ä¸ªæ­»èƒ¡åŒï¼ˆç¡®ä¿ä¸ä¸å…¶ä»–è·¯å¾„ç›¸é‚»ï¼Œä¸”ä¸ä»ç»ˆç‚¹é™„è¿‘å»¶ä¼¸ï¼‰
                const deadEndCount = 8 + Math.floor(Math.random() * 5); // 8-12ä¸ª
                for (let i = 0; i < deadEndCount; i++) {
                    // ä»æ­£ç¡®è·¯å¾„ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªç‚¹ä½œä¸ºæ­»èƒ¡åŒçš„èµ·ç‚¹
                    // æ’é™¤ç»ˆç‚¹å’Œæ­£ç¡®è·¯å¾„çš„æœ€å5ä¸ªç‚¹ï¼ˆè®©æœ€åå‡ æ­¥æ˜æ˜¾ï¼‰
                    const excludeLastSteps = Math.min(5, correctPath.length - 1);
                    const availablePoints = correctPath.slice(0, correctPath.length - excludeLastSteps);
                    
                    if (availablePoints.length === 0) continue;
                    
                    const startPoint = availablePoints[Math.floor(Math.random() * availablePoints.length)];
                    
                    // ä»è¿™ä¸ªç‚¹å»¶ä¼¸3-5æ­¥çš„æ­»èƒ¡åŒï¼ˆé™åˆ¶åœ¨5æ­¥å†…ï¼‰
                    const deadEndSteps = 3 + Math.floor(Math.random() * 3);
                    let dx = startPoint.x;
                    let dy = startPoint.y;
                    
                    for (let step = 0; step < deadEndSteps; step++) {
                        const directions = [];
                        
                        // æ‰¾å‡ºå¯ä»¥å»¶ä¼¸çš„æ–¹å‘ï¼ˆç¡®ä¿ä¸ä¼šä¸ç°æœ‰è·¯å¾„ç›¸é‚»ï¼‰
                        // å‘å·¦
                        if (dx > 1 && maze[dy][dx - 1] === 1) {
                            let valid = true;
                            // æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰è·¯å¾„ï¼ˆé™¤äº†èµ·ç‚¹ï¼‰
                            if (dy > 0 && maze[dy - 1][dx - 1] === 0) valid = false;
                            if (dy < MAZE_SIZE - 1 && maze[dy + 1][dx - 1] === 0) valid = false;
                            if (dx > 1 && maze[dy][dx - 2] === 0) valid = false;
                            if (valid) directions.push({ddx: -1, ddy: 0});
                        }
                        
                        // å‘å³
                        if (dx < MAZE_SIZE - 2 && maze[dy][dx + 1] === 1) {
                            let valid = true;
                            if (dy > 0 && maze[dy - 1][dx + 1] === 0) valid = false;
                            if (dy < MAZE_SIZE - 1 && maze[dy + 1][dx + 1] === 0) valid = false;
                            if (dx < MAZE_SIZE - 2 && maze[dy][dx + 2] === 0) valid = false;
                            if (valid) directions.push({ddx: 1, ddy: 0});
                        }
                        
                        // å‘ä¸Š
                        if (dy > 1 && maze[dy - 1][dx] === 1) {
                            let valid = true;
                            if (dx > 0 && maze[dy - 1][dx - 1] === 0) valid = false;
                            if (dx < MAZE_SIZE - 1 && maze[dy - 1][dx + 1] === 0) valid = false;
                            if (dy > 1 && maze[dy - 2][dx] === 0) valid = false;
                            if (valid) directions.push({ddx: 0, ddy: -1});
                        }
                        
                        // å‘ä¸‹
                        if (dy < MAZE_SIZE - 2 && maze[dy + 1][dx] === 1) {
                            let valid = true;
                            if (dx > 0 && maze[dy + 1][dx - 1] === 0) valid = false;
                            if (dx < MAZE_SIZE - 1 && maze[dy + 1][dx + 1] === 0) valid = false;
                            if (dy < MAZE_SIZE - 2 && maze[dy + 2][dx] === 0) valid = false;
                            if (valid) directions.push({ddx: 0, ddy: 1});
                        }
                        
                        if (directions.length > 0) {
                            const dir = directions[Math.floor(Math.random() * directions.length)];
                            dx += dir.ddx;
                            dy += dir.ddy;
                            maze[dy][dx] = 0;
                } else {
                            break; // æ— æ³•ç»§ç»­å»¶ä¼¸
                        }
                    }
                }
                
                // éªŒè¯æœ€çŸ­è·¯å¾„é•¿åº¦ï¼ˆç›®æ ‡22æ­¥ï¼‰
                pathLength = findShortestPath();
                
                if (pathLength >= 22 && pathLength <= 26) {
                    break; // æ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„è¿·å®«
                }
                
                attempts++;
            }
            
            shortestPathLength = pathLength;
            
            // åˆå§‹åŒ–ç©å®¶ä½ç½®
            playerPos = { x: 0, y: 0 };
            explored[0][0] = true;
            visitedCells.clear();
            visitedCells.add('0,0');
            moveHistory = [{ x: 0, y: 0 }];
            steps = 1; // èµ·ç‚¹ç®—1æ­¥
            
            updateInfo();
            drawMaze();
        }

        // è·å–å¯ç§»åŠ¨æ–¹å‘ï¼ˆä¸‹ä¸€æ­¥æç¤ºï¼‰
        function getNextStepHints() {
            const directions = [
                { dx: 0, dy: -1 },
                { dx: 1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }
            ];
            
            const hints = [];
            for (let dir of directions) {
                const newX = playerPos.x + dir.dx;
                const newY = playerPos.y + dir.dy;
                
                if (newX >= 0 && newX < MAZE_SIZE && newY >= 0 && newY < MAZE_SIZE && maze[newY][newX] === 0) {
                    hints.push({ x: newX, y: newY });
                }
            }
            return hints;
        }

        // ç»˜åˆ¶è¿·å®«
        function drawMaze() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶è¿·å®«æ ¼å­
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const px = x * CELL_SIZE;
                    const py = y * CELL_SIZE;
                    
                    if (explored[y][x]) {
                        // å·²æ¢ç´¢åŒºåŸŸ
                        if (maze[y][x] === 1) {
                            // å¢™å£ - æ·±ç°è‰²
                            ctx.fillStyle = '#4a4a4a';
                        } else {
                            // å·²æ¢ç´¢è·¯å¾„ - ç™½è‰²
                            ctx.fillStyle = '#ffffff';
                        }
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = '#cccccc';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
                    } else {
                        // æœªæ¢ç´¢åŒºåŸŸ - æ·¡ç²‰è‰²
                        ctx.fillStyle = '#ffb6c1';
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = '#ff69b4';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
            
            // ç»˜åˆ¶ä¸‹ä¸€æ­¥æç¤ºï¼ˆå¯èµ°çš„æ ¼å­ï¼‰
            const nextSteps = getNextStepHints();
            for (let step of nextSteps) {
                const px = step.x * CELL_SIZE;
                const py = step.y * CELL_SIZE;
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
            }
            
            // ç»˜åˆ¶èµ·ç‚¹é—¨ï¼ˆå·¦å¼€é—¨emojiï¼‰
            if (playerPos.x !== 0 || playerPos.y !== 0) {
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ğŸšª', 0 * CELL_SIZE + CELL_SIZE / 2, 0 * CELL_SIZE + CELL_SIZE / 2);
            }
            
            // ç»˜åˆ¶å‡ºå£é—¨ï¼ˆå³å¼€é—¨emojiï¼‰
            if (explored[MAZE_SIZE - 1][MAZE_SIZE - 1]) {
                ctx.font = '20px Arial';
                ctx.fillText('ğŸšª', (MAZE_SIZE - 1) * CELL_SIZE + CELL_SIZE / 2, (MAZE_SIZE - 1) * CELL_SIZE + CELL_SIZE / 2);
            }
            
            // ç»˜åˆ¶ç©å®¶ä½ç½®ï¼šå°äººemoji + æ¤°å­emoji
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // å…ˆç»˜åˆ¶æ¤°å­ï¼ˆåº•å±‚ï¼‰
            ctx.fillText('ğŸ¥¥', playerPos.x * CELL_SIZE + CELL_SIZE / 2, playerPos.y * CELL_SIZE + CELL_SIZE / 2);
            // å†ç»˜åˆ¶å°äººï¼ˆä¸Šå±‚ï¼Œç¨å¾®åç§»ï¼‰
            ctx.font = '18px Arial';
            ctx.fillText('ğŸƒ', playerPos.x * CELL_SIZE + CELL_SIZE / 2 + 8, playerPos.y * CELL_SIZE + CELL_SIZE / 2 - 6);
        }

        // ç»˜åˆ¶è¿·å®«å…¨å›¾é¢„è§ˆï¼ˆæ¸¸æˆç»“æŸåæ˜¾ç¤ºï¼‰
        function drawPreview() {
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // å°†æ­£ç¡®è·¯å¾„è½¬æ¢ä¸ºSetä¾¿äºæŸ¥æ‰¾
            const correctPathSet = new Set();
            for (let pos of correctPath) {
                correctPathSet.add(`${pos.x},${pos.y}`);
            }
            
            // ç»˜åˆ¶æ‰€æœ‰è¿·å®«æ ¼å­
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const px = x * CELL_SIZE;
                    const py = y * CELL_SIZE;
                    
                    if (maze[y][x] === 1) {
                        // å¢™å£
                        previewCtx.fillStyle = '#2a2a2a';
                    } else {
                        // è·¯å¾„
                        const cellKey = `${x},${y}`;
                        if (correctPathSet.has(cellKey)) {
                            // æ­£ç¡®è·¯å¾„ - é«˜äº®ç»¿è‰²
                            previewCtx.fillStyle = '#00ff88';
                        } else {
                            // æ­»èƒ¡åŒ - æš—æ·¡ç°è‰²
                            previewCtx.fillStyle = '#555555';
                        }
                    }
                    previewCtx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                    previewCtx.strokeStyle = '#333333';
                    previewCtx.lineWidth = 1;
                    previewCtx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
                }
            }
            
            // ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹
            previewCtx.font = '20px Arial';
            previewCtx.textAlign = 'center';
            previewCtx.textBaseline = 'middle';
            previewCtx.fillText('ğŸšª', 0 * CELL_SIZE + CELL_SIZE / 2, 0 * CELL_SIZE + CELL_SIZE / 2);
            previewCtx.fillText('ğŸšª', (MAZE_SIZE - 1) * CELL_SIZE + CELL_SIZE / 2, (MAZE_SIZE - 1) * CELL_SIZE + CELL_SIZE / 2);
        }

        // ç§»åŠ¨
        function move(direction) {
            let newX = playerPos.x;
            let newY = playerPos.y;
            
            switch (direction) {
                case 'up': newY--; break;
                case 'down': newY++; break;
                case 'left': newX--; break;
                case 'right': newX++; break;
            }
            
            // æ£€æŸ¥è¾¹ç•Œå’Œå¢™å£ï¼ˆé™é»˜å¤„ç†ï¼Œä¸æç¤ºï¼‰
            if (newX < 0 || newX >= MAZE_SIZE || newY < 0 || newY >= MAZE_SIZE) {
                return;
            }
            
            if (maze[newY][newX] === 1) {
                return;
            }
            
            // ç§»åŠ¨æˆåŠŸ
            playerPos.x = newX;
            playerPos.y = newY;
            explored[newY][newX] = true;
            moveHistory.push({ x: newX, y: newY });
            
            // ä»…ç»Ÿè®¡æœªèµ°è¿‡çš„æ ¼å­
            const cellKey = `${newX},${newY}`;
            if (!visitedCells.has(cellKey)) {
                visitedCells.add(cellKey);
            steps++;
            }
            
            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å‡ºå£
            if (newX === exitPos.x && newY === exitPos.y) {
                gameEnded = true;
                document.getElementById('previewContainer').style.display = 'block';
                drawPreview();
                showMessage('ğŸ‰ æ­å–œé€šå…³ï¼', `ä½ ç”¨äº† ${steps} æ­¥æ‰¾åˆ°äº†å‡ºå£ï¼\næœ€çŸ­è·¯å¾„ï¼š${shortestPathLength} æ­¥`);
            }
            
            updateInfo();
            drawMaze();
        }

        // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
        function updateInfo() {
            document.getElementById('steps').textContent = steps;
            document.getElementById('shortestPath').textContent = shortestPathLength > 0 ? `${shortestPathLength} æ­¥` : 'è®¡ç®—ä¸­...';
            
            // æ˜¾ç¤ºä½ç½®
            if (playerPos.x === 0 && playerPos.y === 0) {
                document.getElementById('position').textContent = 'èµ·ç‚¹ ğŸšª';
            } else if (playerPos.x === MAZE_SIZE - 1 && playerPos.y === MAZE_SIZE - 1) {
                document.getElementById('position').textContent = 'ç»ˆç‚¹ ğŸšª';
            } else {
                document.getElementById('position').textContent = `(${playerPos.x}, ${playerPos.y})`;
            }
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(title, text) {
            document.getElementById('messageTitle').textContent = title;
            document.getElementById('messageText').textContent = text;
            document.getElementById('message').classList.add('show');
        }

        // éšè—æ¶ˆæ¯
        function hideMessage() {
            document.getElementById('message').classList.remove('show');
        }

        // æ–°æ¸¸æˆ
        function newGame() {
            if (confirm('ç¡®å®šè¦å¼€å§‹æ–°æ¸¸æˆå—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸¢å¤±ï¼')) {
                gameEnded = false;
                document.getElementById('previewContainer').style.display = 'none';
                generateMaze();
                showMessage('ğŸ® æ–°æ¸¸æˆå¼€å§‹', 'è¿·å®«å·²é‡æ–°ç”Ÿæˆï¼Œç¥ä½ å¥½è¿ï¼');
            }
        }

        // å¯¼å‡ºå­˜æ¡£
        function exportGame() {
            const saveData = {
                version: '3.0',
                maze: maze,
                playerPos: playerPos,
                exitPos: exitPos,
                explored: explored,
                visitedCells: Array.from(visitedCells),
                moveHistory: moveHistory,
                steps: steps,
                shortestPathLength: shortestPathLength,
                correctPath: correctPath,
                gameEnded: gameEnded,
                timestamp: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(saveData);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `maze_save_${Date.now()}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            showMessage('ğŸ’¾ å¯¼å‡ºæˆåŠŸ', 'æ¸¸æˆå­˜æ¡£å·²ä¿å­˜åˆ°æœ¬åœ°ï¼');
        }

        // å¯¼å…¥å­˜æ¡£
        function importGame() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const saveData = JSON.parse(event.target.result);
                        
                        maze = saveData.maze;
                        playerPos = saveData.playerPos;
                        exitPos = saveData.exitPos;
                        explored = saveData.explored;
                        visitedCells = new Set(saveData.visitedCells || []);
                        moveHistory = saveData.moveHistory;
                        steps = saveData.steps;
                        shortestPathLength = saveData.shortestPathLength || 0;
                        correctPath = saveData.correctPath || [];
                        gameEnded = saveData.gameEnded || false;
                        
                        // å¦‚æœæ¸¸æˆå·²ç»“æŸï¼Œæ˜¾ç¤ºé¢„è§ˆ
                        if (gameEnded) {
                            document.getElementById('previewContainer').style.display = 'block';
                            drawPreview();
                        } else {
                            document.getElementById('previewContainer').style.display = 'none';
                        }
                        
                        updateInfo();
                        drawMaze();
                        showMessage('ğŸ“‚ å¯¼å…¥æˆåŠŸ', 'æ¸¸æˆå­˜æ¡£å·²åŠ è½½ï¼');
                    } catch (error) {
                        showMessage('âŒ å¯¼å…¥å¤±è´¥', 'å­˜æ¡£æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    move('up');
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    move('down');
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    move('left');
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    move('right');
                    break;
            }
        });

        // åˆå§‹åŒ–æ¸¸æˆ
        generateMaze();
    </script>
</body>
</html>


