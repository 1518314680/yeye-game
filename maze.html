<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¿·å®«æ¸¸æˆ - æ¤°æ¤°ç”µç«</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Orbitron", "Microsoft YaHei", Arial, sans-serif;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f35 50%, #0f1420 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #fff;
            position: relative;
            overflow-x: hidden;
        }

        .bg-image {
            width: 100%;
            max-width: 1400px;
            height: auto;
            display: block;
            margin: 0 auto 20px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        .container {
            max-width: 1200px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 42px;
            font-weight: 900;
            background: linear-gradient(90deg, #00ffff, #00d4ff, #ffa500, #00ffff);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            animation: titleGlow 3s ease-in-out infinite;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.8));
        }

        @keyframes titleGlow {
            0%, 100% {
                filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.8)) brightness(1);
            }
            50% {
                filter: drop-shadow(0 0 20px rgba(0, 255, 255, 1)) brightness(1.2);
            }
        }

        .subtitle {
            font-size: 20px;
            color: #00ffff;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .game-area {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }

        .maze-container {
            background: linear-gradient(145deg, rgba(10, 15, 30, 0.8), rgba(5, 10, 20, 0.9));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 
                0 0 30px rgba(0, 255, 255, 0.2),
                inset 0 0 50px rgba(0, 0, 0, 0.5);
        }

        .maze-canvas {
            display: block;
            background: #111;
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }

        .preview-container {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid rgba(0, 255, 255, 0.3);
        }

        .preview-title {
            font-size: 16px;
            color: #ffa500;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }

        .preview-canvas {
            display: block;
            background: #0a0a0a;
            border: 1px solid rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            opacity: 0.8;
        }

        .control-panel {
            background: linear-gradient(145deg, rgba(0, 60, 80, 0.3), rgba(0, 40, 60, 0.4));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 
                0 0 25px rgba(0, 255, 255, 0.2),
                inset 0 0 30px rgba(0, 0, 0, 0.3);
            min-width: 280px;
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-title {
            font-size: 18px;
            color: #ffa500;
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: 2px solid rgba(255, 165, 0, 0.5);
            padding-bottom: 5px;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }

        .info-label {
            color: #00ffff;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
        }

        .info-value {
            color: #ffa500;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }

        .game-rules {
            background: linear-gradient(145deg, rgba(0, 40, 60, 0.3), rgba(0, 30, 50, 0.4));
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .rules-title {
            font-size: 16px;
            color: #ffa500;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }

        .rule-item {
            font-size: 13px;
            color: #a0d0e0;
            line-height: 1.6;
            margin: 6px 0;
            padding-left: 8px;
        }

        .rule-highlight {
            color: #00ff88;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
        }

        .rule-warning {
            color: #ff6b6b;
            font-weight: bold;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .direction-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 10px 0;
        }

        .control-btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 200, 255, 0.3));
            border: 2px solid #00ffff;
            color: #00ffff;
            font-size: 24px;
            font-weight: bold;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .control-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 5px 30px rgba(0, 255, 255, 0.6);
            border-color: #ffa500;
            color: #ffa500;
        }

        .control-btn:active:not(:disabled) {
            transform: translateY(-1px);
        }

        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .action-btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 200, 255, 0.3));
            border: 2px solid #00ffff;
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 30px rgba(0, 255, 255, 0.6);
            border-color: #ffa500;
            color: #ffa500;
        }

        .action-btn.success {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 200, 100, 0.3));
            border-color: #00ff88;
            color: #00ff88;
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(20, 25, 45, 0.98), rgba(15, 20, 35, 1));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 
                0 0 60px rgba(0, 255, 255, 0.3),
                0 0 100px rgba(255, 165, 0, 0.2);
            z-index: 2000;
            text-align: center;
            display: none;
        }

        .message.show {
            display: block;
            animation: messageAppear 0.3s ease-out;
        }

        @keyframes messageAppear {
            from {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .message-title {
            font-size: 32px;
            color: #00ffff;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .message-text {
            font-size: 18px;
            color: #a0d0e0;
            margin-bottom: 20px;
        }

        .difficulty-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .difficulty-modal.hidden {
            display: none;
        }

        .difficulty-content {
            background: linear-gradient(145deg, rgba(20, 25, 45, 0.98), rgba(15, 20, 35, 1));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 
                0 0 80px rgba(0, 255, 255, 0.4),
                0 0 120px rgba(255, 165, 0, 0.2);
            max-width: 600px;
            width: 90%;
        }

        .difficulty-title {
            font-size: 32px;
            color: #00ffff;
            font-weight: bold;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }

        .difficulty-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .difficulty-card {
            background: linear-gradient(145deg, rgba(0, 60, 80, 0.4), rgba(0, 40, 60, 0.5));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 30px 25px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.2);
            flex: 1;
            min-width: 220px;
            text-align: center;
        }

        .difficulty-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 40px rgba(0, 255, 255, 0.6);
            border-color: #ffa500;
        }

        .difficulty-card-title {
            font-size: 24px;
            color: #ffa500;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }

        .difficulty-card-info {
            font-size: 14px;
            color: #a0d0e0;
            margin: 8px 0;
        }

        .difficulty-card-price {
            font-size: 20px;
            color: #00ff88;
            font-weight: bold;
            margin-top: 15px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        @media (max-width: 1024px) {
            .bg-image {
                max-width: 100%;
            }
        }

        @media (max-width: 768px) {
            .bg-image {
                margin-bottom: 15px;
                border-radius: 5px;
            }

            .title {
                font-size: 32px;
            }

            .game-area {
                flex-direction: column;
            }

            .maze-canvas {
                max-width: 100%;
            }

            .control-panel {
                width: 100%;
            }

            .game-rules {
                padding: 12px;
            }

            .rules-title {
                font-size: 14px;
            }

            .rule-item {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- éš¾åº¦é€‰æ‹©æ¨¡æ€æ¡† -->
    <div class="difficulty-modal" id="difficultyModal">
        <div class="difficulty-content">
            <div class="difficulty-title">ğŸ® é€‰æ‹©éš¾åº¦ ğŸ®</div>
            <div class="difficulty-options">
                <div class="difficulty-card" onclick="selectDifficulty('normal')">
                    <div class="difficulty-card-title">ğŸ—ºï¸ æ™®é€šç‰ˆ</div>
                    <div class="difficulty-card-info">ğŸ“ è¿·å®«å¤§å°ï¼š10Ã—10</div>
                    <div class="difficulty-card-info">ğŸ’° ä»·æ ¼ï¼š3888R</div>
                    <div class="difficulty-card-info">ğŸ’ ä¿åº•ï¼š8888W</div>
                    <div class="difficulty-card-price">ç‚¹å‡»å¼€å§‹</div>
                </div>
                <div class="difficulty-card" onclick="selectDifficulty('hard')">
                    <div class="difficulty-card-title">ğŸ”¥ å›°éš¾ç‰ˆ</div>
                    <div class="difficulty-card-info">ğŸ“ è¿·å®«å¤§å°ï¼š15Ã—15</div>
                    <div class="difficulty-card-info">ğŸ’° ä»·æ ¼ï¼š7888R</div>
                    <div class="difficulty-card-info">ğŸ’ ä¿åº•ï¼š13888W</div>
                    <div class="difficulty-card-price">ç‚¹å‡»å¼€å§‹</div>
                </div>
            </div>
        </div>
    </div>

    <img src="beijingtu.jpg" alt="æ¤°æ¤°ç”µç«" class="bg-image">

    <div class="container">
        <div class="header">
            <div class="title">è¿·å®«æ¸¸æˆ</div>
            <div class="subtitle" id="subtitle">è¯·é€‰æ‹©éš¾åº¦</div>
        </div>

        <div class="game-area">
            <div class="maze-container">
                <canvas id="mazeCanvas" class="maze-canvas" width="300" height="300"></canvas>
                <div class="preview-container" id="previewContainer" style="display: none;">
                    <div class="preview-title">ğŸ—ºï¸ å®Œæ•´è¿·å®«åœ°å›¾</div>
                    <canvas id="previewCanvas" class="preview-canvas" width="300" height="300"></canvas>
                </div>
            </div>

            <div class="control-panel">
                <div class="info-section">
                    <div class="info-title">ğŸ® æ–¹å‘æ§åˆ¶</div>
                    <div class="direction-pad">
                        <div></div>
                        <button class="control-btn" id="btnUp" onclick="move('up')">â†‘</button>
                        <div></div>
                        <button class="control-btn" id="btnLeft" onclick="move('left')">â†</button>
                        <button class="control-btn" id="btnDown" onclick="move('down')">â†“</button>
                        <button class="control-btn" id="btnRight" onclick="move('right')">â†’</button>
                    </div>
                </div>
                <div class="game-rules">
                    <div class="rules-title">ğŸ“– æ¸¸æˆè¯´æ˜</div>
                    <div class="rule-item">ğŸ—ºï¸ è¿·å®«éšæœºç”Ÿæˆï¼Œ<span class="rule-highlight">æœ‰ä¸”ä»…æœ‰ä¸€æ¡æ­£è§£è·¯çº¿</span></div>
                    <div class="rule-item">ğŸ’ æ¸¸æˆå†…æ‘¸åˆ°å‡ æ ¼å­çº¢ï¼Œå¯ä»¥èµ°å‡ æ­¥</div>
                    <div class="rule-item">ğŸ”™ åé€€è§„åˆ™ï¼š</div>
                    <div class="rule-item" style="padding-left: 20px;">
                        â€¢ <span class="rule-highlight">æ™®é€šç‰ˆ</span>ï¼šå¯åé€€ <span class="rule-warning">2/4/6</span> æ­¥
                    </div>
                    <div class="rule-item" style="padding-left: 20px;">
                        â€¢ <span class="rule-highlight">å›°éš¾ç‰ˆ</span>ï¼šå¯åé€€ <span class="rule-warning">5/8/10</span> æ­¥
                    </div>
                </div>
                <div class="info-section">
                    <div class="info-title">ğŸ“Š æ¸¸æˆä¿¡æ¯</div>
                    <div class="info-item">
                        <span class="info-label">ğŸ‘£ å·²èµ°æ­¥æ•°:</span>
                        <span class="info-value" id="steps">0</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ğŸ¯ æœ€çŸ­è·¯å¾„:</span>
                        <span class="info-value" id="shortestPath">?</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ğŸ“ å½“å‰ä½ç½®:</span>
                        <span class="info-value" id="position">èµ·ç‚¹</span>
                    </div>
                </div>

                <div class="controls">
                    <button class="action-btn" onclick="newGame()">ğŸ² æ–°æ¸¸æˆ</button>
                    <button class="action-btn success" onclick="exportGame()">ğŸ’¾ å¯¼å‡ºå­˜æ¡£</button>
                    <button class="action-btn success" onclick="importGame()">ğŸ“‚ å¯¼å…¥å­˜æ¡£</button>
                    <button class="action-btn" onclick="location.href='index.html'">ğŸ  è¿”å›é¦–é¡µ</button>
                </div>
            </div>
        </div>
    </div>

    <div class="message" id="message">
        <div class="message-title" id="messageTitle"></div>
        <div class="message-text" id="messageText"></div>
        <button class="action-btn" onclick="hideMessage()">ç¡®å®š</button>
    </div>

    <script>
        // éš¾åº¦é…ç½®
        const DIFFICULTY_CONFIG = {
            normal: {
                name: 'æ™®é€šç‰ˆ',
                size: 10,
                price: '3888R',
                guarantee: '8888W',
                targetSteps: { min: 18, max: 25 },
                deadEnds: { min: 4, max: 6 },
                deadEndLength: { min: 2, max: 6 },
                excludeLastSteps: 5,
                retreatSteps: [2, 4, 6]  // å¯åé€€æ­¥æ•°é€‰é¡¹
            },
            hard: {
                name: 'å›°éš¾ç‰ˆ',
                size: 15,
                price: '7888R',
                guarantee: '13888W',
                targetSteps: { min: 45, max: 55 },
                deadEnds: { min: 8, max: 12 },
                deadEndLength: { min: 5, max: 10 },
                excludeLastSteps: 2,
                retreatSteps: [5, 8, 10]  // å¯åé€€æ­¥æ•°é€‰é¡¹
            }
        };

        let MAZE_SIZE = 10;
        let CELL_SIZE = 30;
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');

        let currentDifficulty = null;
        let maze = [];
        let playerPos = { x: 0, y: 0 };
        let exitPos = { x: MAZE_SIZE - 1, y: MAZE_SIZE - 1 };
        let explored = [];
        let visitedCells = new Set(); // è®°å½•å·²èµ°è¿‡çš„æ ¼å­ï¼ˆç”¨äºæ­¥æ•°ç»Ÿè®¡ï¼‰
        let moveHistory = [];
        let steps = 0;
        let shortestPathLength = 0;
        let correctPath = []; // å­˜å‚¨æ­£ç¡®è·¯å¾„
        let gameEnded = false;

        // é€‰æ‹©éš¾åº¦
        function selectDifficulty(difficulty) {
            currentDifficulty = difficulty;
            const config = DIFFICULTY_CONFIG[difficulty];
            
            // æ›´æ–°è¿·å®«å¤§å°
            MAZE_SIZE = config.size;
            exitPos = { x: MAZE_SIZE - 1, y: MAZE_SIZE - 1 };
            
            // æ ¹æ®è¿·å®«å¤§å°è°ƒæ•´æ ¼å­å¤§å°ï¼ˆä¿æŒç”»å¸ƒå¤§å°ä¸º300x300ï¼‰
            CELL_SIZE = Math.floor(300 / MAZE_SIZE);
            
            // æ›´æ–°å‰¯æ ‡é¢˜
            document.getElementById('subtitle').textContent = 
                `${config.name} ${config.size}Ã—${config.size} - ä»·æ ¼${config.price} ä¿åº•${config.guarantee}`;
            
            // éšè—éš¾åº¦é€‰æ‹©æ¨¡æ€æ¡†
            document.getElementById('difficultyModal').classList.add('hidden');
            
            // ç”Ÿæˆè¿·å®«
            generateMaze();
        }

        // æ£€æŸ¥æŸä¸ªä½ç½®æ˜¯å¦å¯ä»¥å®‰å…¨åœ°æ·»åŠ ä¸ºè·¯å¾„ï¼ˆç¡®ä¿ä¸ä¼šä¸å…¶ä»–è·¯å¾„ç›¸é‚»ï¼‰
        function canPlacePath(x, y, fromX, fromY) {
            // æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦åœ¨è¾¹ç•Œå†…ä¸”æ˜¯å¢™
            if (x < 0 || x >= MAZE_SIZE || y < 0 || y >= MAZE_SIZE || maze[y][x] === 0) {
                return false;
            }
            
            // æ£€æŸ¥å››ä¸ªæ–¹å‘çš„é‚»å±…ï¼ˆä¸Šä¸‹å·¦å³ï¼‰
            const directions = [
                {dx: 0, dy: -1}, // ä¸Š
                {dx: 1, dy: 0},  // å³
                {dx: 0, dy: 1},  // ä¸‹
                {dx: -1, dy: 0}  // å·¦
            ];
            
            let pathCount = 0;
            for (let dir of directions) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;
                
                // æ£€æŸ¥æ˜¯å¦è¶Šç•Œ
                if (nx < 0 || nx >= MAZE_SIZE || ny < 0 || ny >= MAZE_SIZE) continue;
                
                // å¦‚æœç›¸é‚»ä½ç½®æ˜¯è·¯å¾„
                if (maze[ny][nx] === 0) {
                    // å¦‚æœæ˜¯æ¥æºä½ç½®ï¼Œè¿™æ˜¯å…è®¸çš„
                    if (nx === fromX && ny === fromY) {
                        pathCount++;
                    } else {
                        // å¦‚æœä¸æ˜¯æ¥æºä½ç½®ï¼Œåˆ™æœ‰å…¶ä»–è·¯å¾„ç›¸é‚»ï¼Œæ— æ•ˆ
                        return false;
                    }
                }
            }
            
            // å¿…é¡»æ°å¥½æœ‰ä¸€ä¸ªç›¸é‚»è·¯å¾„ï¼ˆæ¥æºä½ç½®ï¼‰ï¼Œå¦åˆ™æ— æ•ˆ
            return pathCount === 1;
        }

        // BFSè®¡ç®—æœ€çŸ­è·¯å¾„
        function findShortestPath() {
            const queue = [{x: 0, y: 0, dist: 0}];
            const visited = Array(MAZE_SIZE).fill(null).map(() => Array(MAZE_SIZE).fill(false));
            visited[0][0] = true;
            
            const directions = [
                { dx: 0, dy: -1 },
                { dx: 1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }
            ];
            
            while (queue.length > 0) {
                const curr = queue.shift();
                
                if (curr.x === MAZE_SIZE - 1 && curr.y === MAZE_SIZE - 1) {
                    return curr.dist;
                }
                
                for (let dir of directions) {
                    const newX = curr.x + dir.dx;
                    const newY = curr.y + dir.dy;
                    
                    if (newX >= 0 && newX < MAZE_SIZE && newY >= 0 && newY < MAZE_SIZE &&
                        !visited[newY][newX] && maze[newY][newX] === 0) {
                        visited[newY][newX] = true;
                        queue.push({x: newX, y: newY, dist: curr.dist + 1});
                    }
                }
            }
            return -1;
        }

        // è¿·å®«ç”Ÿæˆ - åˆ›å»ºå”¯ä¸€æ­£ç¡®è·¯å¾„ + 3-5ä¸ªæ­»èƒ¡åŒï¼ˆè·¯å¾„ä¹‹é—´æœ‰å¢™éš”å¼€ï¼‰
        function generateMaze() {
            let attempts = 0;
            let pathLength = 0;
            
            // é‡å¤ç”Ÿæˆç›´åˆ°æ»¡è¶³è·¯å¾„é•¿åº¦è¦æ±‚
            while (attempts < 100) {
                // åˆå§‹åŒ–è¿·å®«ï¼Œå…¨éƒ¨ä¸ºå¢™
                maze = Array(MAZE_SIZE).fill(null).map(() => Array(MAZE_SIZE).fill(1));
                explored = Array(MAZE_SIZE).fill(null).map(() => Array(MAZE_SIZE).fill(false));
                correctPath = [];
                
                // ç”Ÿæˆå”¯ä¸€æ­£ç¡®è·¯å¾„ï¼ˆä½¿ç”¨DFSéšæœºæ¸¸èµ°ï¼Œå¯ä»¥å‘ä»»æ„æ–¹å‘ï¼‰
                let x = 0, y = 0;
                correctPath.push({x, y});
                maze[y][x] = 0;
                
                // ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ç”Ÿæˆæ›²æŠ˜è·¯å¾„
                const config = DIFFICULTY_CONFIG[currentDifficulty] || DIFFICULTY_CONFIG.normal;
                const targetSteps = config.targetSteps.min + Math.floor(Math.random() * (config.targetSteps.max - config.targetSteps.min + 1));
                let stepCount = 0;
                let attempts = 0;
                const maxAttempts = 1000;
                
                while (stepCount < targetSteps && attempts < maxAttempts) {
                    attempts++;
                    const possibleMoves = [];
                    
                    // å››ä¸ªæ–¹å‘éƒ½å¯ä»¥å°è¯•ï¼ˆä¸Šä¸‹å·¦å³ï¼‰
                    const directions = [
                        {dx: 0, dy: -1, name: 'up'},    // ä¸Š
                        {dx: 1, dy: 0, name: 'right'},  // å³
                        {dx: 0, dy: 1, name: 'down'},   // ä¸‹
                        {dx: -1, dy: 0, name: 'left'}   // å·¦
                    ];
                    
                    for (let dir of directions) {
                        const nx = x + dir.dx;
                        const ny = y + dir.dy;
                        
                        // æ£€æŸ¥è¾¹ç•Œ
                        if (nx < 0 || nx >= MAZE_SIZE || ny < 0 || ny >= MAZE_SIZE) continue;
                        
                        // å¦‚æœè¿™ä¸ªæ ¼å­å·²ç»æ˜¯è·¯å¾„äº†ï¼Œè·³è¿‡
                        if (maze[ny][nx] === 0) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¼šä¸å·²æœ‰è·¯å¾„ç›¸é‚»ï¼ˆé™¤äº†æ¥çš„æ–¹å‘ï¼‰
                        let isValid = true;
                        
                        // æ£€æŸ¥å››å‘¨æ˜¯å¦æœ‰å…¶ä»–è·¯å¾„ï¼ˆé™¤äº†å½“å‰ä½ç½®ï¼‰
                        const checkDirs = [
                            {dx: 0, dy: -1}, {dx: 1, dy: 0}, 
                            {dx: 0, dy: 1}, {dx: -1, dy: 0}
                        ];
                        
                        for (let check of checkDirs) {
                            const cx = nx + check.dx;
                            const cy = ny + check.dy;
                            
                            // è·³è¿‡å½“å‰ä½ç½®
                            if (cx === x && cy === y) continue;
                            
                            // æ£€æŸ¥æ˜¯å¦è¶Šç•Œ
                            if (cx < 0 || cx >= MAZE_SIZE || cy < 0 || cy >= MAZE_SIZE) continue;
                            
                            // å¦‚æœå‘¨å›´æœ‰è·¯å¾„ï¼Œåˆ™æ— æ•ˆ
                            if (maze[cy][cx] === 0) {
                                isValid = false;
                                break;
                            }
                        }
                        
                        if (isValid) {
                            possibleMoves.push({dx: dir.dx, dy: dir.dy});
                        }
                    }
                    
                    if (possibleMoves.length > 0) {
                        // ä¼˜å…ˆé€‰æ‹©é è¿‘ç»ˆç‚¹çš„æ–¹å‘ï¼Œä½†ä¿ç•™éšæœºæ€§
                        const towardsEnd = [];
                        const others = [];
                        
                        for (let move of possibleMoves) {
                            const nx = x + move.dx;
                            const ny = y + move.dy;
                            const distToEnd = Math.abs(nx - (MAZE_SIZE - 1)) + Math.abs(ny - (MAZE_SIZE - 1));
                            const currentDist = Math.abs(x - (MAZE_SIZE - 1)) + Math.abs(y - (MAZE_SIZE - 1));
                            
                            if (distToEnd < currentDist) {
                                towardsEnd.push(move);
                            } else {
                                others.push(move);
                            }
                        }
                        
                        // 70%æ¦‚ç‡é€‰æ‹©é è¿‘ç»ˆç‚¹çš„æ–¹å‘ï¼Œ30%é€‰æ‹©å…¶ä»–æ–¹å‘ï¼ˆå¢åŠ æ›²æŠ˜ï¼‰
                        let selectedMove;
                        if (towardsEnd.length > 0 && Math.random() < 0.7) {
                            selectedMove = towardsEnd[Math.floor(Math.random() * towardsEnd.length)];
                        } else if (others.length > 0) {
                            selectedMove = others[Math.floor(Math.random() * others.length)];
                        } else if (towardsEnd.length > 0) {
                            selectedMove = towardsEnd[Math.floor(Math.random() * towardsEnd.length)];
                        } else {
                            selectedMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        }
                        
                        x += selectedMove.dx;
                        y += selectedMove.dy;
                        correctPath.push({x, y});
                        maze[y][x] = 0;
                        stepCount++;
                        attempts = 0; // é‡ç½®å°è¯•è®¡æ•°
                    }
                }
                
                // ç¡®ä¿è¿æ¥åˆ°ç»ˆç‚¹ï¼ˆä½¿ç”¨æœ€çŸ­è·¯å¾„ï¼‰
                while (x !== MAZE_SIZE - 1 || y !== MAZE_SIZE - 1) {
                    let moved = false;
                    
                    // å°è¯•å‘å³ç§»åŠ¨
                    if (x < MAZE_SIZE - 1 && maze[y][x + 1] !== 0) {
                        x++;
                        correctPath.push({x, y});
                        maze[y][x] = 0;
                        moved = true;
                    }
                    // å°è¯•å‘ä¸‹ç§»åŠ¨
                    else if (y < MAZE_SIZE - 1 && maze[y + 1][x] !== 0) {
                        y++;
                        correctPath.push({x, y});
                        maze[y][x] = 0;
                        moved = true;
                    }
                    // å¦‚æœå³å’Œä¸‹éƒ½ä¸è¡Œï¼Œå°è¯•å…¶ä»–æ–¹å‘
                    else {
                        const dirs = [{dx:0,dy:-1}, {dx:1,dy:0}, {dx:0,dy:1}, {dx:-1,dy:0}];
                        for (let dir of dirs) {
                            const nx = x + dir.dx;
                            const ny = y + dir.dy;
                            if (nx >= 0 && nx < MAZE_SIZE && ny >= 0 && ny < MAZE_SIZE && maze[ny][nx] !== 0) {
                                x = nx;
                                y = ny;
                                correctPath.push({x, y});
                                maze[y][x] = 0;
                                moved = true;
                                break;
                            }
                        }
                    }
                    
                    if (!moved) break; // æ— æ³•ç»§ç»­ï¼Œé€€å‡º
                }
                
                // æ·»åŠ æ­»èƒ¡åŒï¼ˆæ•°é‡å’Œé•¿åº¦æ ¹æ®éš¾åº¦é…ç½®ï¼‰
                const targetDeadEnds = config.deadEnds.min + Math.floor(Math.random() * (config.deadEnds.max - config.deadEnds.min + 1));
                const deadEndPaths = []; // å­˜å‚¨æ‰€æœ‰æ­»èƒ¡åŒè·¯å¾„ç‚¹ï¼Œç”¨äºåç»­åˆ†æ”¯
                let successfulDeadEnds = 0;
                let totalAttempts = 0;
                const maxDeadEndAttempts = targetDeadEnds * 10; // æœ€å¤šå°è¯•æ¬¡æ•°
                
                while (successfulDeadEnds < targetDeadEnds && totalAttempts < maxDeadEndAttempts) {
                    totalAttempts++;
                    
                    // ä»æ­£ç¡®è·¯å¾„ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªç‚¹ä½œä¸ºæ­»èƒ¡åŒçš„èµ·ç‚¹
                    // æ’é™¤ç»ˆç‚¹å’Œæ­£ç¡®è·¯å¾„çš„æœ€åNä¸ªç‚¹ï¼ˆå›°éš¾ç‰ˆæ’é™¤æ›´å°‘ï¼Œå¢åŠ è¿·æƒ‘æ€§ï¼‰
                    const excludeLastSteps = Math.min(config.excludeLastSteps, correctPath.length - 1);
                    const availablePoints = correctPath.slice(0, correctPath.length - excludeLastSteps);
                    
                    if (availablePoints.length === 0) break;
                    
                    const startPoint = availablePoints[Math.floor(Math.random() * availablePoints.length)];
                    
                    // ä»è¿™ä¸ªç‚¹å»¶ä¼¸æ­»èƒ¡åŒï¼ˆå›°éš¾ç‰ˆå»¶ä¼¸æ›´é•¿ï¼‰
                    const deadEndSteps = config.deadEndLength.min + Math.floor(Math.random() * (config.deadEndLength.max - config.deadEndLength.min + 1));
                    let dx = startPoint.x;
                    let dy = startPoint.y;
                    const currentDeadEnd = [];
                    
                    for (let step = 0; step < deadEndSteps; step++) {
                        const directions = [];
                        
                        // æ£€æŸ¥å››ä¸ªæ–¹å‘ï¼Œä½¿ç”¨ä¸¥æ ¼çš„éªŒè¯å‡½æ•°
                        const checkDirs = [
                            {ddx: -1, ddy: 0}, // å·¦
                            {ddx: 1, ddy: 0},  // å³
                            {ddx: 0, ddy: -1}, // ä¸Š
                            {ddx: 0, ddy: 1}   // ä¸‹
                        ];
                        
                        for (let dir of checkDirs) {
                            const newX = dx + dir.ddx;
                            const newY = dy + dir.ddy;
                            
                            if (canPlacePath(newX, newY, dx, dy)) {
                                directions.push(dir);
                            }
                        }
                        
                        if (directions.length > 0) {
                            const dir = directions[Math.floor(Math.random() * directions.length)];
                            dx += dir.ddx;
                            dy += dir.ddy;
                            maze[dy][dx] = 0;
                            currentDeadEnd.push({x: dx, y: dy});
                        } else {
                            break; // æ— æ³•ç»§ç»­å»¶ä¼¸
                        }
                    }
                    
                    // åªä¿å­˜è‡³å°‘æœ‰1æ ¼çš„æ­»èƒ¡åŒ
                    if (currentDeadEnd.length >= 1) {
                        deadEndPaths.push(currentDeadEnd);
                        successfulDeadEnds++;
                    }
                }
                
                // å›°éš¾ç‰ˆï¼šåœ¨æ­»èƒ¡åŒä¸Šæ·»åŠ åˆ†æ”¯æ­»èƒ¡åŒï¼ˆå¢å¼ºè¿·æƒ‘æ€§ï¼‰
                if (currentDifficulty === 'hard' && deadEndPaths.length > 0) {
                    const branchCount = Math.floor(deadEndPaths.length / 3); // ä¸‰åˆ†ä¹‹ä¸€çš„æ­»èƒ¡åŒä¼šæœ‰åˆ†æ”¯
                    for (let b = 0; b < branchCount; b++) {
                        const randomDeadEnd = deadEndPaths[Math.floor(Math.random() * deadEndPaths.length)];
                        if (randomDeadEnd.length < 4) continue; // å¤ªçŸ­çš„æ­»èƒ¡åŒä¸åˆ†æ”¯
                        
                        // åªä»æ­»èƒ¡åŒçš„æœ«ç«¯ï¼ˆæœ€åä¸€ä¸ªç‚¹ï¼‰å»¶ä¼¸åˆ†æ”¯ï¼Œé¿å…è·¯å¾„ç›¸é‚»é—®é¢˜
                        const branchPoint = randomDeadEnd[randomDeadEnd.length - 1];
                        const branchLength = 2 + Math.floor(Math.random() * 3); // 2-4æ­¥ï¼Œé¿å…è¿‡é•¿
                        
                        let bx = branchPoint.x;
                        let by = branchPoint.y;
                        
                        for (let step = 0; step < branchLength; step++) {
                            const directions = [];
                            
                            // æ£€æŸ¥å››ä¸ªæ–¹å‘ï¼Œä½¿ç”¨ä¸¥æ ¼çš„éªŒè¯å‡½æ•°
                            const checkDirs = [
                                {ddx: -1, ddy: 0}, // å·¦
                                {ddx: 1, ddy: 0},  // å³
                                {ddx: 0, ddy: -1}, // ä¸Š
                                {ddx: 0, ddy: 1}   // ä¸‹
                            ];
                            
                            for (let dir of checkDirs) {
                                const newX = bx + dir.ddx;
                                const newY = by + dir.ddy;
                                
                                if (canPlacePath(newX, newY, bx, by)) {
                                    directions.push(dir);
                                }
                            }
                            
                            if (directions.length > 0) {
                                const dir = directions[Math.floor(Math.random() * directions.length)];
                                bx += dir.ddx;
                                by += dir.ddy;
                                maze[by][bx] = 0;
                            } else {
                                break;
                            }
                        }
                    }
                }
                
                // éªŒè¯æœ€çŸ­è·¯å¾„é•¿åº¦
                pathLength = findShortestPath();
                const minPath = config.targetSteps.min + 4;
                const maxPath = config.targetSteps.max + 1;
                
                if (pathLength >= minPath && pathLength <= maxPath) {
                    break; // æ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„è¿·å®«
                }
                
                attempts++;
            }
            
            shortestPathLength = pathLength;
            
            // åˆå§‹åŒ–ç©å®¶ä½ç½®
            playerPos = { x: 0, y: 0 };
            
            // åˆå§‹æ¢ç´¢ç©å®¶å‘¨å›´3x3èŒƒå›´
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const exploreX = 0 + dx;
                    const exploreY = 0 + dy;
                    if (exploreX >= 0 && exploreX < MAZE_SIZE && exploreY >= 0 && exploreY < MAZE_SIZE) {
                        explored[exploreY][exploreX] = true;
                    }
                }
            }
            
            visitedCells.clear();
            visitedCells.add('0,0');
            moveHistory = [{ x: 0, y: 0 }];
            steps = 1; // èµ·ç‚¹ç®—1æ­¥
            
            updateInfo();
            drawMaze();
        }

        // ç»˜åˆ¶è¿·å®«
        function drawMaze() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶è¿·å®«æ ¼å­
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const px = x * CELL_SIZE;
                    const py = y * CELL_SIZE;
                    
                    if (explored[y][x]) {
                        // å·²æ¢ç´¢åŒºåŸŸ
                        if (maze[y][x] === 1) {
                            // å¢™å£ - æ·±è“è‰²
                            ctx.fillStyle = '#1a2540';
                        } else {
                            // å·²æ¢ç´¢è·¯å¾„ - ç™½è‰²
                            ctx.fillStyle = '#ffffff';
                        }
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = '#666666';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
                    } else {
                        // æœªæ¢ç´¢åŒºåŸŸ - ç°è‰²
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = '#555555';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
            
            // ç»˜åˆ¶èµ·ç‚¹é—¨ï¼ˆå·¦å¼€é—¨emojiï¼‰- é«˜äº®æ˜¾ç¤º
            if (playerPos.x !== 0 || playerPos.y !== 0) {
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillText('ğŸšª', 0 * CELL_SIZE + CELL_SIZE / 2, 0 * CELL_SIZE + CELL_SIZE / 2);
                ctx.shadowBlur = 0;
            }
            
            // ç»˜åˆ¶å‡ºå£é—¨ï¼ˆå³å¼€é—¨emojiï¼‰- é«˜äº®æ˜¾ç¤º
            if (explored[MAZE_SIZE - 1][MAZE_SIZE - 1]) {
                ctx.font = '20px Arial';
                ctx.shadowColor = '#ffa500';
                ctx.shadowBlur = 10;
                ctx.fillText('ğŸšª', (MAZE_SIZE - 1) * CELL_SIZE + CELL_SIZE / 2, (MAZE_SIZE - 1) * CELL_SIZE + CELL_SIZE / 2);
                ctx.shadowBlur = 0;
            }
            
            // ç»˜åˆ¶ç©å®¶ä½ç½®ï¼šå°äººemoji + æ¤°å­emoji - é«˜äº®æ˜¾ç¤º
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // å…ˆç»˜åˆ¶æ¤°å­ï¼ˆåº•å±‚ï¼‰- æ©™è‰²å…‰æ™•
            ctx.shadowColor = '#ffa500';
            ctx.shadowBlur = 15;
            ctx.fillText('ğŸ¥¥', playerPos.x * CELL_SIZE + CELL_SIZE / 2, playerPos.y * CELL_SIZE + CELL_SIZE / 2);
            // å†ç»˜åˆ¶å°äººï¼ˆä¸Šå±‚ï¼Œç¨å¾®åç§»ï¼‰- é’è‰²å…‰æ™•
            ctx.font = '18px Arial';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.fillText('ğŸƒ', playerPos.x * CELL_SIZE + CELL_SIZE / 2 + 8, playerPos.y * CELL_SIZE + CELL_SIZE / 2 - 6);
            ctx.shadowBlur = 0;
        }

        // ç»˜åˆ¶è¿·å®«å…¨å›¾é¢„è§ˆï¼ˆæ¸¸æˆç»“æŸåæ˜¾ç¤ºï¼‰
        function drawPreview() {
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // å°†æ­£ç¡®è·¯å¾„è½¬æ¢ä¸ºSetä¾¿äºæŸ¥æ‰¾
            const correctPathSet = new Set();
            for (let pos of correctPath) {
                correctPathSet.add(`${pos.x},${pos.y}`);
            }
            
            // ç»˜åˆ¶æ‰€æœ‰è¿·å®«æ ¼å­
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const px = x * CELL_SIZE;
                    const py = y * CELL_SIZE;
                    
                    if (maze[y][x] === 1) {
                        // å¢™å£
                        previewCtx.fillStyle = '#2a2a2a';
                    } else {
                        // è·¯å¾„
                        const cellKey = `${x},${y}`;
                        if (correctPathSet.has(cellKey)) {
                            // æ­£ç¡®è·¯å¾„ - é«˜äº®ç»¿è‰²
                            previewCtx.fillStyle = '#00ff88';
                        } else {
                            // æ­»èƒ¡åŒ - æš—æ·¡ç°è‰²
                            previewCtx.fillStyle = '#555555';
                        }
                    }
                    previewCtx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                    previewCtx.strokeStyle = '#333333';
                    previewCtx.lineWidth = 1;
                    previewCtx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
                }
            }
            
            // ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹
            previewCtx.font = '20px Arial';
            previewCtx.textAlign = 'center';
            previewCtx.textBaseline = 'middle';
            previewCtx.fillText('ğŸšª', 0 * CELL_SIZE + CELL_SIZE / 2, 0 * CELL_SIZE + CELL_SIZE / 2);
            previewCtx.fillText('ğŸšª', (MAZE_SIZE - 1) * CELL_SIZE + CELL_SIZE / 2, (MAZE_SIZE - 1) * CELL_SIZE + CELL_SIZE / 2);
        }

        // ç§»åŠ¨
        function move(direction) {
            let newX = playerPos.x;
            let newY = playerPos.y;
            
            switch (direction) {
                case 'up': newY--; break;
                case 'down': newY++; break;
                case 'left': newX--; break;
                case 'right': newX++; break;
            }
            
            // æ£€æŸ¥è¾¹ç•Œå’Œå¢™å£ï¼ˆé™é»˜å¤„ç†ï¼Œä¸æç¤ºï¼‰
            if (newX < 0 || newX >= MAZE_SIZE || newY < 0 || newY >= MAZE_SIZE) {
                return;
            }
            
            if (maze[newY][newX] === 1) {
                return;
            }
            
            // ç§»åŠ¨æˆåŠŸ
            playerPos.x = newX;
            playerPos.y = newY;
            
            // æ¢ç´¢ç©å®¶å‘¨å›´3x3èŒƒå›´ï¼ˆ9æ ¼ï¼‰
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const exploreX = newX + dx;
                    const exploreY = newY + dy;
                    if (exploreX >= 0 && exploreX < MAZE_SIZE && exploreY >= 0 && exploreY < MAZE_SIZE) {
                        explored[exploreY][exploreX] = true;
                    }
                }
            }
            
            moveHistory.push({ x: newX, y: newY });
            
            // ä»…ç»Ÿè®¡æœªèµ°è¿‡çš„æ ¼å­
            const cellKey = `${newX},${newY}`;
            if (!visitedCells.has(cellKey)) {
                visitedCells.add(cellKey);
                steps++;
            }
            
            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å‡ºå£
            if (newX === exitPos.x && newY === exitPos.y) {
                gameEnded = true;
                document.getElementById('previewContainer').style.display = 'block';
                drawPreview();
                showMessage('ğŸ‰ æ­å–œé€šå…³ï¼', `ä½ ç”¨äº† ${steps} æ­¥æ‰¾åˆ°äº†å‡ºå£ï¼\næœ€çŸ­è·¯å¾„ï¼š${shortestPathLength} æ­¥`);
            }
            
            updateInfo();
            drawMaze();
        }

        // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
        function updateInfo() {
            document.getElementById('steps').textContent = steps;
            document.getElementById('shortestPath').textContent = shortestPathLength > 0 ? `${shortestPathLength} æ­¥` : 'è®¡ç®—ä¸­...';
            
            // æ˜¾ç¤ºä½ç½®
            if (playerPos.x === 0 && playerPos.y === 0) {
                document.getElementById('position').textContent = 'èµ·ç‚¹ ğŸšª';
            } else if (playerPos.x === MAZE_SIZE - 1 && playerPos.y === MAZE_SIZE - 1) {
                document.getElementById('position').textContent = 'ç»ˆç‚¹ ğŸšª';
            } else {
                document.getElementById('position').textContent = `(${playerPos.x}, ${playerPos.y})`;
            }
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(title, text) {
            document.getElementById('messageTitle').textContent = title;
            document.getElementById('messageText').textContent = text;
            document.getElementById('message').classList.add('show');
        }

        // éšè—æ¶ˆæ¯
        function hideMessage() {
            document.getElementById('message').classList.remove('show');
        }

        // æ–°æ¸¸æˆ
        function newGame() {
            if (confirm('ç¡®å®šè¦å¼€å§‹æ–°æ¸¸æˆå—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸¢å¤±ï¼')) {
                gameEnded = false;
                document.getElementById('previewContainer').style.display = 'none';
                document.getElementById('subtitle').textContent = 'è¯·é€‰æ‹©éš¾åº¦';
                document.getElementById('difficultyModal').classList.remove('hidden');
            }
        }

        // å¯¼å‡ºå­˜æ¡£
        function exportGame() {
            const saveData = {
                version: '4.0',
                difficulty: currentDifficulty,
                mazeSize: MAZE_SIZE,
                maze: maze,
                playerPos: playerPos,
                exitPos: exitPos,
                explored: explored,
                visitedCells: Array.from(visitedCells),
                moveHistory: moveHistory,
                steps: steps,
                shortestPathLength: shortestPathLength,
                correctPath: correctPath,
                gameEnded: gameEnded,
                timestamp: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(saveData);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `maze_save_${Date.now()}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            showMessage('ğŸ’¾ å¯¼å‡ºæˆåŠŸ', 'æ¸¸æˆå­˜æ¡£å·²ä¿å­˜åˆ°æœ¬åœ°ï¼');
        }

        // å¯¼å…¥å­˜æ¡£
        function importGame() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const saveData = JSON.parse(event.target.result);
                        
                        // æ¢å¤éš¾åº¦é…ç½®
                        currentDifficulty = saveData.difficulty || 'normal';
                        MAZE_SIZE = saveData.mazeSize || saveData.maze.length;
                        CELL_SIZE = Math.floor(300 / MAZE_SIZE);
                        
                        // æ›´æ–°å‰¯æ ‡é¢˜
                        const config = DIFFICULTY_CONFIG[currentDifficulty];
                        if (config) {
                            document.getElementById('subtitle').textContent = 
                                `${config.name} ${config.size}Ã—${config.size} - ä»·æ ¼${config.price} ä¿åº•${config.guarantee}`;
                        }
                        
                        // éšè—éš¾åº¦é€‰æ‹©æ¨¡æ€æ¡†
                        document.getElementById('difficultyModal').classList.add('hidden');
                        
                        maze = saveData.maze;
                        playerPos = saveData.playerPos;
                        exitPos = saveData.exitPos;
                        explored = saveData.explored;
                        visitedCells = new Set(saveData.visitedCells || []);
                        moveHistory = saveData.moveHistory;
                        steps = saveData.steps;
                        shortestPathLength = saveData.shortestPathLength || 0;
                        correctPath = saveData.correctPath || [];
                        gameEnded = saveData.gameEnded || false;
                        
                        // å¦‚æœæ¸¸æˆå·²ç»“æŸï¼Œæ˜¾ç¤ºé¢„è§ˆ
                        if (gameEnded) {
                            document.getElementById('previewContainer').style.display = 'block';
                            drawPreview();
                        } else {
                            document.getElementById('previewContainer').style.display = 'none';
                        }
                        
                        updateInfo();
                        drawMaze();
                        showMessage('ğŸ“‚ å¯¼å…¥æˆåŠŸ', 'æ¸¸æˆå­˜æ¡£å·²åŠ è½½ï¼');
                    } catch (error) {
                        showMessage('âŒ å¯¼å…¥å¤±è´¥', 'å­˜æ¡£æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    move('up');
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    move('down');
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    move('left');
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    move('right');
                    break;
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆåï¼Œç­‰å¾…ç”¨æˆ·é€‰æ‹©éš¾åº¦
        // ä¸å†è‡ªåŠ¨ç”Ÿæˆè¿·å®«
    </script>
</body>
</html>


